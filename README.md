<img width="488" height="482" alt="image" src="https://github.com/user-attachments/assets/78965e3c-62c4-4ba2-a185-9ef75e4e767d" />Вопрос №1
Метод с остатком (%): Быстрый и понятный. Это стандартный способ, использующий простую математику целых чисел.

Метод с делением (/): Медленный и неочевидный. Он задействует более сложные и медленные вычисления с плавающей точкой.

Вопрос №2
Так как это queue и dequeue, я решил использовать стеки, так как это стандарт в университете — сначала мы изучаем именно это, что гораздо медленнее и ненадёжнее в больших случаях.
Во втором классе я использовал библиотеку, уже написанную на C, которая примерно в два раза быстрее.
Я добавил функцию тестирования производительности с использованием 100000 операций добавления и удаления из очереди и записал время для каждого класса. Вот результаты:
FIFODeque 0.013100 секунд
FIFOStacks 0.020830 секунд


Вопрос №3
Я выбрал алгоритм timsort, так как он задокументирован как стабильный и хорошо работает как с малыми, так и с большими случаями.
<img width="488" height="482" alt="310f329f" src="https://github.com/user-attachments/assets/568812a9-5b21-4d28-bd37-a57b6df14e58" />

Timsort статистически является лучшим, потому что он сочетает гарантированную производительность O(n log n) сортировки слиянием с O(n) скоростью сортировки вставками на частично отсортированных данных.
